<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jarvis Voice Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
        }

        .container {
            text-align: center;
            padding: 2rem;
            max-width: 600px;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: #888;
            margin-bottom: 2rem;
        }

        .status {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
        }

        .status-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .status-item.connected {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        .status-item.disconnected {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        .mic-button {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 2rem;
            box-shadow: 0 10px 40px rgba(0, 217, 255, 0.3);
        }

        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 50px rgba(0, 217, 255, 0.5);
        }

        .mic-button.recording {
            animation: pulse 1s infinite;
            background: linear-gradient(135deg, #ff4444, #ff8800);
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        .mic-button svg {
            width: 60px;
            height: 60px;
            fill: #1a1a2e;
        }

        .instruction {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 2rem;
        }

        .chat-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: left;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }

        .message {
            padding: 0.75rem 1rem;
            margin: 0.5rem 0;
            border-radius: 10px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            background: rgba(0, 217, 255, 0.2);
            margin-left: 2rem;
        }

        .message.jarvis {
            background: rgba(0, 255, 136, 0.2);
            margin-right: 2rem;
        }

        .message.error {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }

        .message.function {
            background: rgba(255, 200, 0, 0.2);
            font-size: 0.85rem;
            color: #ffc800;
        }

        .message-label {
            font-size: 0.75rem;
            opacity: 0.7;
            margin-bottom: 0.25rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ü§ñ JARVIS</h1>
        <p class="subtitle">Voice Assistant with Local AI</p>

        <div class="status">
            <div class="status-item" id="discord-status">Discord: ...</div>
            <div class="status-item" id="voice-status">Voice: ...</div>
        </div>

        <button class="mic-button" id="mic-btn">
            <svg viewBox="0 0 24 24">
                <path
                    d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1 1.93c-3.94-.49-7-3.85-7-7.93V7h2v1c0 2.76 2.24 5 5 5s5-2.24 5-5V7h2v1c0 4.08-3.06 7.44-7 7.93V19h4v2H7v-2h4v-3.07z" />
            </svg>
        </button>

        <p class="instruction">‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏û‡∏π‡∏î ‚Ä¢ ‡πÉ‡∏ä‡πâ /join ‡πÉ‡∏ô Discord ‡∏Å‡πà‡∏≠‡∏ô</p>

        <div class="chat-box" id="chat-box">
            <div class="message jarvis">
                <div class="message-label">Jarvis</div>
                ‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö‡πÄ‡∏à‡πâ‡∏≤‡∏ô‡∏≤‡∏¢ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ñ‡∏£‡∏±‡∏ö
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;

        const micBtn = document.getElementById('mic-btn');
        const chatBox = document.getElementById('chat-box');
        const discordStatus = document.getElementById('discord-status');
        const voiceStatus = document.getElementById('voice-status');

        // Connect WebSocket
        function connect() {
            ws = new WebSocket(`ws://${location.host}/ws/voice`);

            ws.onopen = () => {
                console.log('Connected');
                updateStatus();
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };

            ws.onclose = () => {
                console.log('Disconnected, reconnecting...');
                setTimeout(connect, 2000);
            };
        }

        function handleMessage(data) {
            if (data.type === 'transcription') {
                addMessage('user', data.text);
            } else if (data.type === 'response') {
                addMessage('jarvis', data.text);
                if (data.function) {
                    addMessage('function', `üîß ${data.function}(${JSON.stringify(data.args || {})})`);
                }
            } else if (data.type === 'error') {
                addMessage('error', data.text);
            }
        }

        function addMessage(type, text) {
            const msg = document.createElement('div');
            msg.className = `message ${type}`;

            const label = document.createElement('div');
            label.className = 'message-label';
            label.textContent = type === 'user' ? '‡∏Ñ‡∏∏‡∏ì' : type === 'jarvis' ? 'Jarvis' : '';

            if (type !== 'function' && type !== 'error') {
                msg.appendChild(label);
            }
            msg.appendChild(document.createTextNode(text));
            chatBox.appendChild(msg);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        async function updateStatus() {
            try {
                const resp = await fetch('/api/status');
                const data = await resp.json();

                discordStatus.textContent = `Discord: ${data.discord ? '‚úÖ' : '‚ùå'}`;
                discordStatus.className = `status-item ${data.discord ? 'connected' : 'disconnected'}`;

                voiceStatus.textContent = `Voice: ${data.voice ? '‚úÖ' : '‚ùå'}`;
                voiceStatus.className = `status-item ${data.voice ? 'connected' : 'disconnected'}`;
            } catch (e) {
                discordStatus.textContent = 'Discord: ‚ùå';
                voiceStatus.textContent = 'Voice: ‚ùå';
            }
        }

        // Recording
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                audioChunks = [];

                mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
                mediaRecorder.onstop = sendAudio;

                mediaRecorder.start();
                isRecording = true;
                micBtn.classList.add('recording');
            } catch (e) {
                addMessage('error', '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡πÇ‡∏ü‡∏ô');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(t => t.stop());
                isRecording = false;
                micBtn.classList.remove('recording');
            }
        }

        async function sendAudio() {
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            const reader = new FileReader();

            reader.onloadend = () => {
                const base64 = reader.result.split(',')[1];
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'audio', data: base64 }));
                }
            };

            reader.readAsDataURL(blob);
        }

        // Event listeners
        micBtn.addEventListener('mousedown', startRecording);
        micBtn.addEventListener('mouseup', stopRecording);
        micBtn.addEventListener('mouseleave', stopRecording);
        micBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startRecording(); });
        micBtn.addEventListener('touchend', stopRecording);

        // Init
        connect();
        setInterval(updateStatus, 5000);
    </script>
</body>

</html>